
import da
PatternExpr_0 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern1_'), da.pat.FreePattern(None)])
PatternExpr_1 = da.pat.FreePattern('a')
PatternExpr_3 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern16_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_5 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern34_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_7 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern52_'), da.pat.FreePattern(None)])
PatternExpr_8 = da.pat.FreePattern('a')
PatternExpr_10 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_11 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_12 = da.pat.FreePattern('p')
PatternExpr_13 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_15 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_17 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_19 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_20 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_22 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_23 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_25 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern149_'), da.pat.BoundPattern('_BoundPattern150_')])
PatternExpr_26 = da.pat.FreePattern('a')
PatternExpr_28 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern164_'), da.pat.FreePattern(None)])
PatternExpr_29 = da.pat.FreePattern('a')
PatternExpr_31 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern179_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_33 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern197_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_35 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern215_'), da.pat.FreePattern(None)])
PatternExpr_36 = da.pat.FreePattern('a')
PatternExpr_38 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_39 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_40 = da.pat.FreePattern('p')
PatternExpr_41 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_43 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_45 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_47 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_48 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_50 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_51 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_53 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern312_'), da.pat.BoundPattern('_BoundPattern313_')])
PatternExpr_54 = da.pat.FreePattern('a')
PatternExpr_56 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern327_'), da.pat.FreePattern(None)])
PatternExpr_57 = da.pat.FreePattern('a')
PatternExpr_59 = da.pat.TuplePattern([da.pat.ConstantPattern('reject'), da.pat.BoundPattern('_BoundPattern342_')])
PatternExpr_61 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern354_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_63 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern372_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_65 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern390_'), da.pat.FreePattern(None)])
PatternExpr_66 = da.pat.FreePattern('a')
PatternExpr_68 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_60 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('reject'), da.pat.BoundPattern('_BoundPattern352_')])])
PatternExpr_69 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_70 = da.pat.FreePattern('p')
PatternExpr_71 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_73 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_75 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_77 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_78 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_80 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_81 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_83 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern487_'), da.pat.BoundPattern('_BoundPattern488_')])
PatternExpr_84 = da.pat.FreePattern('a')
PatternExpr_86 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern502_'), da.pat.FreePattern(None)])
PatternExpr_87 = da.pat.FreePattern('a')
PatternExpr_89 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern517_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_91 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern535_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_93 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern553_'), da.pat.FreePattern(None)])
PatternExpr_94 = da.pat.FreePattern('a')
PatternExpr_96 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_97 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_98 = da.pat.FreePattern('p')
PatternExpr_99 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_101 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_103 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_105 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_106 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_108 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_109 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_111 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern650_'), da.pat.BoundPattern('_BoundPattern651_')])
PatternExpr_112 = da.pat.FreePattern('a')
PatternExpr_114 = da.pat.TuplePattern([da.pat.ConstantPattern('correctness'), da.pat.FreePattern('s')])
PatternExpr_115 = da.pat.TuplePattern([da.pat.ConstantPattern('learners'), da.pat.FreePattern('val')])
PatternExpr_116 = da.pat.TuplePattern([da.pat.ConstantPattern('acceptor_choose'), da.pat.FreePattern('val')])
PatternExpr_117 = da.pat.TuplePattern([da.pat.ConstantPattern('timing'), da.pat.FreePattern('x')])
import sys
from random import randint
import time
import copy
import numpy as np
import matplotlib.pyplot as plt

def anyof(s):
    "return any element of set s if s is not empty or 'None' otherwise"
    return (next(iter(s)) if s else None)

def loss_array(arr, ratio):
    i = 0
    l = len(arr)
    arr1 = copy.deepcopy(arr)
    while (i < (ratio * l)):
        arr1.pop()
        i = (i + 1)
    return arr1

class Proposer_orig(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Proposer_origReceivedEvent_0 = []
        self._Proposer_origReceivedEvent_1 = []
        self._Proposer_origReceivedEvent_2 = []
        self._Proposer_origReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_origReceivedEvent_0', PatternExpr_0, sources=[PatternExpr_1], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_origReceivedEvent_1', PatternExpr_3, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_origReceivedEvent_2', PatternExpr_5, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_origReceivedEvent_3', PatternExpr_7, sources=[PatternExpr_8], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_origReceivedEvent_4', PatternExpr_10, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_orig_handler_0])])

    def setup(self, acceptors, r, d, w, dr):
        self.acceptors = acceptors
        self.r = r
        self.d = d
        self.w = w
        self.dr = dr
        self.n = None
        self.majority = self.acceptors
        self.values_proposed = []
        self.total_rounds = 0

    def _da_run_internal(self):
        while True:
            self.to_consent()

    def to_consent(self):
        self.n = ((0, self.id) if (self.n == None) else ((self.n[0] + 1), self.id))
        time.sleep(self.d)
        self._send(('prepare', self.n), loss_array(self.majority, self.r))
        _st_label_29 = 0
        while (_st_label_29 == 0):
            _st_label_29 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern12_, _BoundPattern13_, _)) in self._Proposer_origReceivedEvent_0 if (_ConstantPattern12_ == 'respond') if (_BoundPattern13_ == self.n)}) > (len(self.acceptors) / 2)):
                v = anyof(({v for (_, _, (_ConstantPattern28_, _BoundPattern29_, (n2, v))) in self._Proposer_origReceivedEvent_1 if (_ConstantPattern28_ == 'respond') if (_BoundPattern29_ == self.n) if (n2 == max({n2 for (_, _, (_ConstantPattern46_, _BoundPattern47_, (n2, _))) in self._Proposer_origReceivedEvent_2 if (_ConstantPattern46_ == 'respond') if (_BoundPattern47_ == self.n)}))} or {randint(1, 100)}))
                self.values_proposed.append(v)
                responded = {a for (_, (_, _, a), (_ConstantPattern63_, _BoundPattern64_, _)) in self._Proposer_origReceivedEvent_3 if (_ConstantPattern63_ == 'respond') if (_BoundPattern64_ == self.n)}
                time.sleep(self.d)
                self._send(('accept', self.n, v), responded)
                self.output('### chose', self.n, v)
                _st_label_29 += 1
            else:
                super()._label('_st_label_29', block=True)
                _st_label_29 -= 1
        self.total_rounds += 1
        time.sleep(self.w)

    def _Proposer_orig_handler_0(self):
        self._send(('correctness', self.values_proposed), self.dr)
        self._send(('timing', time.process_time()), self.dr)
        self.output('terminating')
        self.exit()
    _Proposer_orig_handler_0._labels = None
    _Proposer_orig_handler_0._notlabels = None

class Acceptor_orig(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Acceptor_origSentEvent_1 = []
        self._Acceptor_origSentEvent_2 = []
        self._Acceptor_origSentEvent_3 = []
        self._Acceptor_origSentEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_origReceivedEvent_0', PatternExpr_11, sources=[PatternExpr_12], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_orig_handler_1]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_origSentEvent_1', PatternExpr_13, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_origSentEvent_2', PatternExpr_15, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_origSentEvent_3', PatternExpr_17, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_origReceivedEvent_4', PatternExpr_19, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_orig_handler_2]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_origSentEvent_5', PatternExpr_20, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_origReceivedEvent_6', PatternExpr_22, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_orig_handler_3])])

    def setup(self, learners, dr, r):
        self.learners = learners
        self.dr = dr
        self.r = r
        pass

    def _da_run_internal(self):
        _st_label_62 = 0
        while (_st_label_62 == 0):
            _st_label_62 += 1
            if False:
                _st_label_62 += 1
            else:
                super()._label('_st_label_62', block=True)
                _st_label_62 -= 1

    def _Acceptor_orig_handler_1(self, n, p):
        n2 = None

        def UniversalOpExpr_0():
            nonlocal n2
            for (_, _, (_ConstantPattern83_, n2, _)) in self._Acceptor_origSentEvent_1:
                if (_ConstantPattern83_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_0():
            max_prop = anyof({(n, v) for (_, _, (_ConstantPattern97_, n, v)) in self._Acceptor_origSentEvent_2 if (_ConstantPattern97_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern111_, n, _)) in self._Acceptor_origSentEvent_3 if (_ConstantPattern111_ == 'accepted')}))})
            self._send(('respond', n, max_prop), p)
    _Acceptor_orig_handler_1._labels = None
    _Acceptor_orig_handler_1._notlabels = None

    def _Acceptor_orig_handler_2(self, n, v):
        n2 = None

        def ExistentialOpExpr_1():
            nonlocal n2
            for (_, _, (_ConstantPattern129_, n2, _)) in self._Acceptor_origSentEvent_5:
                if (_ConstantPattern129_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_1()):
            self._send(('accepted', n, v), self.learners)
            self._send(('acceptor_choose', v), self.dr)
    _Acceptor_orig_handler_2._labels = None
    _Acceptor_orig_handler_2._notlabels = None

    def _Acceptor_orig_handler_3(self):
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Acceptor_orig_handler_3._labels = None
    _Acceptor_orig_handler_3._notlabels = None

class Learner_orig(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Learner_origReceivedEvent_0 = []
        self._Learner_origReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_origReceivedEvent_0', PatternExpr_23, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_origReceivedEvent_1', PatternExpr_25, sources=[PatternExpr_26], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, acceptors, dr):
        self.acceptors = acceptors
        self.dr = dr
        pass

    def _da_run_internal(self):
        self.learn()
        self._send(('timing', time.process_time()), self.dr)
        self.output('terminating')
        self.exit()

    def learn(self):
        n = a = v = None

        def ExistentialOpExpr_2():
            nonlocal n, a, v
            for (_, _, (_ConstantPattern145_, n, v)) in self._Learner_origReceivedEvent_0:
                if (_ConstantPattern145_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern160_, _BoundPattern161_, _BoundPattern162_)) in self._Learner_origReceivedEvent_1 if (_ConstantPattern160_ == 'accepted') if (_BoundPattern161_ == n) if (_BoundPattern162_ == v)}) > (len(self.acceptors) / 2)):
                        return True
            return False
        _st_label_67 = 0
        while (_st_label_67 == 0):
            _st_label_67 += 1
            if ExistentialOpExpr_2():
                self.output('learned', n, v)
                self._send(('learners', v), self.dr)
                _st_label_67 += 1
            else:
                super()._label('_st_label_67', block=True)
                _st_label_67 -= 1

class Proposer_to(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Proposer_toReceivedEvent_0 = []
        self._Proposer_toReceivedEvent_1 = []
        self._Proposer_toReceivedEvent_2 = []
        self._Proposer_toReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_toReceivedEvent_0', PatternExpr_28, sources=[PatternExpr_29], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_toReceivedEvent_1', PatternExpr_31, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_toReceivedEvent_2', PatternExpr_33, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_toReceivedEvent_3', PatternExpr_35, sources=[PatternExpr_36], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_toReceivedEvent_4', PatternExpr_38, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_to_handler_4])])

    def setup(self, acceptors, r, d, w, tp, dr):
        self.acceptors = acceptors
        self.r = r
        self.d = d
        self.w = w
        self.tp = tp
        self.dr = dr
        self.n = None
        self.majority = self.acceptors
        self.values_proposed = []
        self.total_rounds = 0

    def _da_run_internal(self):
        while True:
            self.to_consent()

    def to_consent(self):
        self.n = ((0, self.id) if (self.n == None) else ((self.n[0] + 1), self.id))
        time.sleep(self.d)
        self._send(('prepare', self.n), loss_array(self.majority, self.r))
        t = time.clock()
        _st_label_86 = 0
        self._timer_start()
        while (_st_label_86 == 0):
            _st_label_86 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern175_, _BoundPattern176_, _)) in self._Proposer_toReceivedEvent_0 if (_ConstantPattern175_ == 'respond') if (_BoundPattern176_ == self.n)}) > (len(self.acceptors) / 2)):
                v = anyof(({v for (_, _, (_ConstantPattern191_, _BoundPattern192_, (n2, v))) in self._Proposer_toReceivedEvent_1 if (_ConstantPattern191_ == 'respond') if (_BoundPattern192_ == self.n) if (n2 == max({n2 for (_, _, (_ConstantPattern209_, _BoundPattern210_, (n2, _))) in self._Proposer_toReceivedEvent_2 if (_ConstantPattern209_ == 'respond') if (_BoundPattern210_ == self.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern226_, _BoundPattern227_, _)) in self._Proposer_toReceivedEvent_3 if (_ConstantPattern226_ == 'respond') if (_BoundPattern227_ == self.n)}
                time.sleep(self.d)
                self.values_proposed.append(v)
                self._send(('accept', self.n, v), responded)
                self.output('### chose', self.n, v)
                _st_label_86 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self.n)
                _st_label_86 += 1
            else:
                super()._label('_st_label_86', block=True, timeout=self.tp)
                _st_label_86 -= 1
        self.total_rounds += 1
        time.sleep(self.w)

    def _Proposer_to_handler_4(self):
        self.output('terminating')
        self._send(('correctness', self.values_proposed), self.dr)
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Proposer_to_handler_4._labels = None
    _Proposer_to_handler_4._notlabels = None

class Acceptor_to(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Acceptor_toSentEvent_1 = []
        self._Acceptor_toSentEvent_2 = []
        self._Acceptor_toSentEvent_3 = []
        self._Acceptor_toSentEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_toReceivedEvent_0', PatternExpr_39, sources=[PatternExpr_40], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_to_handler_5]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_toSentEvent_1', PatternExpr_41, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_toSentEvent_2', PatternExpr_43, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_toSentEvent_3', PatternExpr_45, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_toReceivedEvent_4', PatternExpr_47, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_to_handler_6]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_toSentEvent_5', PatternExpr_48, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_toReceivedEvent_6', PatternExpr_50, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_to_handler_7])])

    def setup(self, learners, dr, r):
        self.learners = learners
        self.dr = dr
        self.r = r
        pass

    def _da_run_internal(self):
        _st_label_120 = 0
        while (_st_label_120 == 0):
            _st_label_120 += 1
            if False:
                _st_label_120 += 1
            else:
                super()._label('_st_label_120', block=True)
                _st_label_120 -= 1

    def _Acceptor_to_handler_5(self, n, p):
        n2 = None

        def UniversalOpExpr_3():
            nonlocal n2
            for (_, _, (_ConstantPattern246_, n2, _)) in self._Acceptor_toSentEvent_1:
                if (_ConstantPattern246_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_3():
            max_prop = anyof({(n, v) for (_, _, (_ConstantPattern260_, n, v)) in self._Acceptor_toSentEvent_2 if (_ConstantPattern260_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern274_, n, _)) in self._Acceptor_toSentEvent_3 if (_ConstantPattern274_ == 'accepted')}))})
            self._send(('respond', n, max_prop), p)
    _Acceptor_to_handler_5._labels = None
    _Acceptor_to_handler_5._notlabels = None

    def _Acceptor_to_handler_6(self, n, v):
        n2 = None

        def ExistentialOpExpr_4():
            nonlocal n2
            for (_, _, (_ConstantPattern292_, n2, _)) in self._Acceptor_toSentEvent_5:
                if (_ConstantPattern292_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_4()):
            self._send(('accepted', n, v), self.learners)
            self._send(('acceptor_choose', v), self.dr)
    _Acceptor_to_handler_6._labels = None
    _Acceptor_to_handler_6._notlabels = None

    def _Acceptor_to_handler_7(self):
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Acceptor_to_handler_7._labels = None
    _Acceptor_to_handler_7._notlabels = None

class Learner_to(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Learner_toReceivedEvent_0 = []
        self._Learner_toReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_toReceivedEvent_0', PatternExpr_51, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_toReceivedEvent_1', PatternExpr_53, sources=[PatternExpr_54], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, acceptors, tl, dr):
        self.acceptors = acceptors
        self.tl = tl
        self.dr = dr
        pass

    def _da_run_internal(self):
        self.learn()
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()

    def learn(self):
        n = v = a = None

        def ExistentialOpExpr_5():
            nonlocal n, v, a
            for (_, _, (_ConstantPattern308_, n, v)) in self._Learner_toReceivedEvent_0:
                if (_ConstantPattern308_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern323_, _BoundPattern324_, _BoundPattern325_)) in self._Learner_toReceivedEvent_1 if (_ConstantPattern323_ == 'accepted') if (_BoundPattern324_ == n) if (_BoundPattern325_ == v)}) > (len(self.acceptors) / 2)):
                        return True
            return False
        _st_label_125 = 0
        self._timer_start()
        while (_st_label_125 == 0):
            _st_label_125 += 1
            if ExistentialOpExpr_5():
                self.output('learned', n, v)
                self._send(('learners', v), self.dr)
                _st_label_125 += 1
            elif self._timer_expired:
                self.output('Acceptor quitting')
                _st_label_125 += 1
            else:
                super()._label('_st_label_125', block=True, timeout=self.tl)
                _st_label_125 -= 1

class Proposer_pe(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Proposer_peReceivedEvent_0 = []
        self._Proposer_peReceivedEvent_1 = []
        self._Proposer_peReceivedEvent_2 = []
        self._Proposer_peReceivedEvent_3 = []
        self._Proposer_peReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_peReceivedEvent_0', PatternExpr_56, sources=[PatternExpr_57], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_peReceivedEvent_1', PatternExpr_59, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_peReceivedEvent_2', PatternExpr_61, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_peReceivedEvent_3', PatternExpr_63, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_peReceivedEvent_4', PatternExpr_65, sources=[PatternExpr_66], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_peReceivedEvent_5', PatternExpr_68, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_pe_handler_8])])

    def setup(self, acceptors, r, d, w, dr):
        self.acceptors = acceptors
        self.r = r
        self.d = d
        self.w = w
        self.dr = dr
        self.n = None
        self.majority = self.acceptors
        self.values_proposed = []
        self.total_rounds = 0

    def _da_run_internal(self):
        while True:
            self.to_consent()

    def to_consent(self):
        self.n = ((0, self.id) if (self.n == None) else ((self.n[0] + 1), self.id))
        time.sleep(self.d)
        self._send(('prepare', self.n), loss_array(self.majority, self.r))
        t = time.clock()
        _st_label_145 = 0
        while (_st_label_145 == 0):
            _st_label_145 += 1
            if ((len({a for (_, (_, _, a), (_ConstantPattern338_, _BoundPattern339_, _)) in self._Proposer_peReceivedEvent_0 if (_ConstantPattern338_ == 'respond') if (_BoundPattern339_ == self.n)}) > (len(self.acceptors) / 2)) or PatternExpr_60.match_iter(self._Proposer_peReceivedEvent_1, _BoundPattern352_=self.n)):
                v = anyof(({v for (_, _, (_ConstantPattern366_, _BoundPattern367_, (n2, v))) in self._Proposer_peReceivedEvent_2 if (_ConstantPattern366_ == 'respond') if (_BoundPattern367_ == self.n) if (n2 == max({n2 for (_, _, (_ConstantPattern384_, _BoundPattern385_, (n2, _))) in self._Proposer_peReceivedEvent_3 if (_ConstantPattern384_ == 'respond') if (_BoundPattern385_ == self.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern401_, _BoundPattern402_, _)) in self._Proposer_peReceivedEvent_4 if (_ConstantPattern401_ == 'respond') if (_BoundPattern402_ == self.n)}
                time.sleep(self.d)
                self.values_proposed.append(v)
                self._send(('accept', self.n, v), responded)
                self.output('### chose', self.n, v)
                _st_label_145 += 1
            else:
                super()._label('_st_label_145', block=True)
                _st_label_145 -= 1
        self.total_rounds += 1
        time.sleep(self.w)

    def _Proposer_pe_handler_8(self):
        self.output('terminating')
        self._send(('correctness', self.values_proposed), self.dr)
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Proposer_pe_handler_8._labels = None
    _Proposer_pe_handler_8._notlabels = None

class Acceptor_pe(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Acceptor_peSentEvent_1 = []
        self._Acceptor_peSentEvent_2 = []
        self._Acceptor_peSentEvent_3 = []
        self._Acceptor_peSentEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_peReceivedEvent_0', PatternExpr_69, sources=[PatternExpr_70], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_pe_handler_9]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_peSentEvent_1', PatternExpr_71, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_peSentEvent_2', PatternExpr_73, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_peSentEvent_3', PatternExpr_75, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_peReceivedEvent_4', PatternExpr_77, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_pe_handler_10]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_peSentEvent_5', PatternExpr_78, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_peReceivedEvent_6', PatternExpr_80, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_pe_handler_11])])

    def setup(self, learners, dr, r):
        self.learners = learners
        self.dr = dr
        self.r = r
        last_preempt = None

    def _da_run_internal(self):
        _st_label_179 = 0
        while (_st_label_179 == 0):
            _st_label_179 += 1
            if False:
                _st_label_179 += 1
            else:
                super()._label('_st_label_179', block=True)
                _st_label_179 -= 1

    def _Acceptor_pe_handler_9(self, n, p):
        n2 = None

        def UniversalOpExpr_6():
            nonlocal n2
            for (_, _, (_ConstantPattern421_, n2, _)) in self._Acceptor_peSentEvent_1:
                if (_ConstantPattern421_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_6():
            max_prop = anyof({(n, v) for (_, _, (_ConstantPattern435_, n, v)) in self._Acceptor_peSentEvent_2 if (_ConstantPattern435_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern449_, n, _)) in self._Acceptor_peSentEvent_3 if (_ConstantPattern449_ == 'accepted')}))})
            self._send(('respond', n, max_prop), p)
        else:
            self._send(('reject', n), p)
    _Acceptor_pe_handler_9._labels = None
    _Acceptor_pe_handler_9._notlabels = None

    def _Acceptor_pe_handler_10(self, n, v):
        n2 = None

        def ExistentialOpExpr_7():
            nonlocal n2
            for (_, _, (_ConstantPattern467_, n2, _)) in self._Acceptor_peSentEvent_5:
                if (_ConstantPattern467_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_7()):
            self._send(('accepted', n, v), self.learners)
            self._send(('acceptor_choose', v), self.dr)
    _Acceptor_pe_handler_10._labels = None
    _Acceptor_pe_handler_10._notlabels = None

    def _Acceptor_pe_handler_11(self):
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Acceptor_pe_handler_11._labels = None
    _Acceptor_pe_handler_11._notlabels = None

class Learner_pe(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Learner_peReceivedEvent_0 = []
        self._Learner_peReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_peReceivedEvent_0', PatternExpr_81, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_peReceivedEvent_1', PatternExpr_83, sources=[PatternExpr_84], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, acceptors, dr):
        self.acceptors = acceptors
        self.dr = dr
        pass

    def _da_run_internal(self):
        self.learn()
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()

    def learn(self):
        n = a = v = None

        def ExistentialOpExpr_8():
            nonlocal n, a, v
            for (_, _, (_ConstantPattern483_, n, v)) in self._Learner_peReceivedEvent_0:
                if (_ConstantPattern483_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern498_, _BoundPattern499_, _BoundPattern500_)) in self._Learner_peReceivedEvent_1 if (_ConstantPattern498_ == 'accepted') if (_BoundPattern499_ == n) if (_BoundPattern500_ == v)}) > (len(self.acceptors) / 2)):
                        return True
            return False
        _st_label_184 = 0
        while (_st_label_184 == 0):
            _st_label_184 += 1
            if ExistentialOpExpr_8():
                self._send(('learners', v), self.dr)
                self.output('learned', n, v)
                _st_label_184 += 1
            else:
                super()._label('_st_label_184', block=True)
                _st_label_184 -= 1

class Proposer_peto(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Proposer_petoReceivedEvent_0 = []
        self._Proposer_petoReceivedEvent_1 = []
        self._Proposer_petoReceivedEvent_2 = []
        self._Proposer_petoReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_petoReceivedEvent_0', PatternExpr_86, sources=[PatternExpr_87], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_petoReceivedEvent_1', PatternExpr_89, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_petoReceivedEvent_2', PatternExpr_91, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_petoReceivedEvent_3', PatternExpr_93, sources=[PatternExpr_94], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Proposer_petoReceivedEvent_4', PatternExpr_96, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_peto_handler_12])])

    def setup(self, acceptors, r, d, w, tp, dr):
        self.acceptors = acceptors
        self.r = r
        self.d = d
        self.w = w
        self.tp = tp
        self.dr = dr
        self.n = None
        self.majority = self.acceptors
        self.values_proposed = []
        self.total_rounds = 0

    def _da_run_internal(self):
        while True:
            self.to_consent()

    def to_consent(self):
        self.n = ((0, self.id) if (self.n == None) else ((self.n[0] + 1), self.id))
        time.sleep(self.d)
        self._send(('prepare', self.n), loss_array(self.majority, self.r))
        t = time.clock()
        _st_label_203 = 0
        self._timer_start()
        while (_st_label_203 == 0):
            _st_label_203 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern513_, _BoundPattern514_, _)) in self._Proposer_petoReceivedEvent_0 if (_ConstantPattern513_ == 'respond') if (_BoundPattern514_ == self.n)}) > (len(self.acceptors) / 2)):
                v = anyof(({v for (_, _, (_ConstantPattern529_, _BoundPattern530_, (n2, v))) in self._Proposer_petoReceivedEvent_1 if (_ConstantPattern529_ == 'respond') if (_BoundPattern530_ == self.n) if (n2 == max({n2 for (_, _, (_ConstantPattern547_, _BoundPattern548_, (n2, _))) in self._Proposer_petoReceivedEvent_2 if (_ConstantPattern547_ == 'respond') if (_BoundPattern548_ == self.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern564_, _BoundPattern565_, _)) in self._Proposer_petoReceivedEvent_3 if (_ConstantPattern564_ == 'respond') if (_BoundPattern565_ == self.n)}
                time.sleep(self.d)
                self.values_proposed.append(v)
                self._send(('accept', self.n, v), responded)
                self.output('### chose', self.n, v)
                _st_label_203 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self.n)
                _st_label_203 += 1
            else:
                super()._label('_st_label_203', block=True, timeout=self.tp)
                _st_label_203 -= 1
        self.total_rounds += 1
        time.sleep(self.w)

    def _Proposer_peto_handler_12(self):
        self.output('terminating')
        self._send(('correctness', self.values_proposed), self.dr)
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Proposer_peto_handler_12._labels = None
    _Proposer_peto_handler_12._notlabels = None

class Acceptor_peto(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Acceptor_petoSentEvent_1 = []
        self._Acceptor_petoSentEvent_2 = []
        self._Acceptor_petoSentEvent_3 = []
        self._Acceptor_petoSentEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_petoReceivedEvent_0', PatternExpr_97, sources=[PatternExpr_98], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_peto_handler_13]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_petoSentEvent_1', PatternExpr_99, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_petoSentEvent_2', PatternExpr_101, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_petoSentEvent_3', PatternExpr_103, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_petoReceivedEvent_4', PatternExpr_105, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_peto_handler_14]), da.pat.EventPattern(da.pat.SentEvent, '_Acceptor_petoSentEvent_5', PatternExpr_106, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Acceptor_petoReceivedEvent_6', PatternExpr_108, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_peto_handler_15])])

    def setup(self, learners, dr, r):
        self.learners = learners
        self.dr = dr
        self.r = r
        pass

    def _da_run_internal(self):
        _st_label_237 = 0
        while (_st_label_237 == 0):
            _st_label_237 += 1
            if False:
                _st_label_237 += 1
            else:
                super()._label('_st_label_237', block=True)
                _st_label_237 -= 1

    def _Acceptor_peto_handler_13(self, n, p):
        n2 = None

        def UniversalOpExpr_9():
            nonlocal n2
            for (_, _, (_ConstantPattern584_, n2, _)) in self._Acceptor_petoSentEvent_1:
                if (_ConstantPattern584_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_9():
            max_prop = anyof({(n, v) for (_, _, (_ConstantPattern598_, n, v)) in self._Acceptor_petoSentEvent_2 if (_ConstantPattern598_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern612_, n, _)) in self._Acceptor_petoSentEvent_3 if (_ConstantPattern612_ == 'accepted')}))})
            self._send(('respond', n, max_prop), p)
    _Acceptor_peto_handler_13._labels = None
    _Acceptor_peto_handler_13._notlabels = None

    def _Acceptor_peto_handler_14(self, n, v):
        n2 = None

        def ExistentialOpExpr_10():
            nonlocal n2
            for (_, _, (_ConstantPattern630_, n2, _)) in self._Acceptor_petoSentEvent_5:
                if (_ConstantPattern630_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_10()):
            self._send(('accepted', n, v), self.learners)
            self._send(('acceptor_choose', v), self.dr)
    _Acceptor_peto_handler_14._labels = None
    _Acceptor_peto_handler_14._notlabels = None

    def _Acceptor_peto_handler_15(self):
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()
    _Acceptor_peto_handler_15._labels = None
    _Acceptor_peto_handler_15._notlabels = None

class Learner_peto(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._Learner_petoReceivedEvent_0 = []
        self._Learner_petoReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_petoReceivedEvent_0', PatternExpr_109, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Learner_petoReceivedEvent_1', PatternExpr_111, sources=[PatternExpr_112], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, acceptors, tl, dr):
        self.acceptors = acceptors
        self.tl = tl
        self.dr = dr
        pass

    def _da_run_internal(self):
        self.learn()
        self.output('terminating')
        self._send(('timing', time.process_time()), self.dr)
        self.exit()

    def learn(self):
        n = v = a = None

        def ExistentialOpExpr_11():
            nonlocal n, v, a
            for (_, _, (_ConstantPattern646_, n, v)) in self._Learner_petoReceivedEvent_0:
                if (_ConstantPattern646_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern661_, _BoundPattern662_, _BoundPattern663_)) in self._Learner_petoReceivedEvent_1 if (_ConstantPattern661_ == 'accepted') if (_BoundPattern662_ == n) if (_BoundPattern663_ == v)}) > (len(self.acceptors) / 2)):
                        return True
            return False
        _st_label_242 = 0
        self._timer_start()
        while (_st_label_242 == 0):
            _st_label_242 += 1
            if ExistentialOpExpr_11():
                self._send(('learners', v), self.dr)
                self.output('learned', n, v)
                _st_label_242 += 1
            elif self._timer_expired:
                self.output('Acceptor terminating')
                _st_label_242 += 1
            else:
                super()._label('_st_label_242', block=True, timeout=self.tl)
                _st_label_242 -= 1

class driverclass(da.DistProcess):

    def __init__(self, parent, initq, channel, props):
        super().__init__(parent, initq, channel, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_driverclassReceivedEvent_0', PatternExpr_114, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._driverclass_handler_16]), da.pat.EventPattern(da.pat.ReceivedEvent, '_driverclassReceivedEvent_1', PatternExpr_115, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._driverclass_handler_17]), da.pat.EventPattern(da.pat.ReceivedEvent, '_driverclassReceivedEvent_2', PatternExpr_116, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._driverclass_handler_18]), da.pat.EventPattern(da.pat.ReceivedEvent, '_driverclassReceivedEvent_3', PatternExpr_117, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._driverclass_handler_19])])

    def setup(self, pal, a, l, n, r, d, w, tp, tl, ml, de, wa):
        self.pal = pal
        self.a = a
        self.l = l
        self.n = n
        self.r = r
        self.d = d
        self.w = w
        self.tp = tp
        self.tl = tl
        self.ml = ml
        self.de = de
        self.wa = wa
        self.f = open('correctness_output', 'w')
        self.proposed_values_set = set()
        self.learners_values = set()
        self.learners_count = 0
        self.accepted_values = set()
        self.proposer_count = 0
        self.time_sum = 0

    def _da_run_internal(self):
        x = 0
        self.f.write('The safety requirements for consensus are:\n')
        self.f.write('1. Only a value that has been proposed may be chosen\n')
        self.f.write('2. Only a single value is chosen\n')
        self.f.write('3. A process never learns that a value has been chosen unless it actually has been.\n')
        m = 0
        ans = {}
        ans2 = {}
        if (m == 0):
            r_d = np.linspace(0, self.r, self.ml)
            d_d = np.linspace(0, self.d, self.de)
            w_d = np.linspace(0, self.w, self.wa)
            for r_dd in r_d:
                for d_dd in d_d:
                    for w_dd in w_d:
                        (a1, a2) = self.runner(r_dd, d_dd, w_dd)
                        ans[(r_dd, d_dd, w_dd)] = a1
                        ans2[(r_dd, d_dd, w_dd)] = a2
            self.graph_draw(ans, ans2, 0, r_d, d_d, w_d)
        self.exit()

    def safety_check(self, round1, algo):
        _st_label_261 = 0
        while (_st_label_261 == 0):
            _st_label_261 += 1
            if (self.learners_count >= (self.l / 2)):
                _st_label_261 += 1
            else:
                super()._label('_st_label_261', block=True)
                _st_label_261 -= 1
        _st_label_262 = 0
        while (_st_label_262 == 0):
            _st_label_262 += 1
            if (self.proposer_count >= self.pal):
                _st_label_262 += 1
            else:
                super()._label('_st_label_262', block=True)
                _st_label_262 -= 1
        if (len(self.learners_values) > 1):
            self.f.write(((((((('round' + str(round1)) + 'for algorithm') + algo) + 'falied. ') + 'More than 1 values accepted. Correctness condition 2 violated. ...failed... Learner : ') + str(self.learners_values)) + '\n '))
        elif (not (len(self.learners_values.difference(self.proposed_values_set)) == 0)):
            self.f.write((((((((('round ' + str(round1)) + ' for algorithm ') + algo) + ' falied. ') + ' Accepted values not one of the proposed values. Correctness condition 1 violated. ...failed... Learner values:') + str(self.learners_values)) + '\n') + str(self.proposed_values_set)))
        elif (not (len(self.learners_values.difference(self.accepted_values)) == 0)):
            self.f.write(((((((((('round' + str(round1)) + 'for algorithm') + algo) + 'falied. ') + 'Learner has learnt a value that has not been chosen by acceptor. Correctness condition 3 violated. ...failed... Learner Values: ') + str(self.learners_values)) + 'Acceptor Values:') + str(self.accepted_values)) + '\n'))
        else:
            self.f.write((((((('All correctness tests for round ' + str(round1)) + ' for algorithm ') + algo) + ' passed. Learner Values: ') + str(self.learners_values)) + '\n'))
        self.proposed_values_set.clear()
        self.learners_values.clear()
        self.learners_count = 0
        self.accepted_values.clear()
        self.proposer_count = 0
        self.f.flush()

    def helper_index(self, w_dd, r_dd, d_dd, num):
        if (num == 1):
            hashind = (r_dd, d_dd, w_dd)
        elif (num == 2):
            hashind = (w_dd, d_dd, r_dd)
        elif (num == 3):
            hashind = (r_dd, w_dd, d_dd)
        return hashind

    def generate_permutations(self, w_d, r_d, d_d, num, time_dict, title, xlabel, ylabel):
        (fig1, ax1) = plt.subplots()
        fig1.suptitle(title)
        original_mix = []
        to_mix = []
        pr_mix = []
        prto_mix = []
        for w_dd in sorted(w_d):
            original = 0
            to = 0
            pr = 0
            prto = 0
            count = 0
            for r_dd in r_d:
                for d_dd in d_d:
                    hashind = self.helper_index(w_dd, r_dd, d_dd, num)
                    original += time_dict[hashind][0]
                    to += time_dict[hashind][1]
                    pr += time_dict[hashind][2]
                    prto += time_dict[hashind][3]
                    count += 1
            original_mix.append(((original * 1000) / count))
            to_mix.append(((to * 1000) / count))
            pr_mix.append(((pr * 1000) / count))
            prto_mix.append(((prto * 1000) / count))
        ax1.plot(w_d, original_mix, 'r', label='Original')
        ax1.plot(w_d, to_mix, 'b', label='Timeout')
        ax1.plot(w_d, pr_mix, 'y', label='Preemption')
        ax1.plot(w_d, prto_mix, 'g', label='Preemption - Timeout')
        plt.legend(loc=2, borderaxespad=0.0)
        ax1.set_xlabel(xlabel)
        ax1.set_ylabel(ylabel)
        lower_limit_y = (min((min(original_mix), min(to_mix), min(pr_mix), min(prto_mix))) - 1)
        upper_limit_y = (max((max(original_mix), max(to_mix), max(pr_mix), max(prto_mix))) + 1)
        mu = np.array(original_mix).mean()
        sigma = np.array(original_mix).std()
        mu1 = np.array(to_mix).mean()
        sigma1 = np.array(to_mix).std()
        mu2 = np.array(pr_mix).mean()
        sigma2 = np.array(prto_mix).std()
        mu3 = np.array(prto_mix).mean()
        sigma3 = np.array(original_mix).std()
        ax1.axis(((min(w_d) - 1), (max(w_d) + 1), lower_limit_y, upper_limit_y))
        textstr = ('$Original$\n$\\mu=%.2f$\n$\\sigma=%.2f$\n$timeout$\n$\\mu=%.2f$\n$\\sigma=%.2f$\n$Preemption$\n$\\mu=%.2f$\n$\\sigma=%.2f$\n$Preemption-timeout$\n$\\mu=%.2f$\n$\\sigma=%.2f$' % (mu, sigma, mu1, sigma1, mu2, sigma2, mu3, sigma3))
        props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
        ax1.text(0.8, 0.95, textstr, transform=ax1.transAxes, fontsize=14, verticalalignment='top', bbox=props)

    def graph_draw(self, time_dict, tot_dict, ind, r_d, d_d, w_d):
        self.generate_permutations(w_d, r_d, d_d, 1, time_dict, 'Process Time Vs Waittime each round', 'Waiting time in Second(s)', 'Total Process time for each run(in Milliseconds)')
        self.generate_permutations(r_d, w_d, d_d, 2, time_dict, 'Process Time Vs Message Loss each round', 'Message Loss in Fraction', 'Total Process time for each run(in Milliseconds)')
        self.generate_permutations(d_d, r_d, w_d, 3, time_dict, 'Process Time Vs Waittime each round', 'Delay in Second(s)', 'Total Process time for each run(in Milliseconds)')
        self.generate_permutations(w_d, r_d, d_d, 1, tot_dict, 'Turnaround Time Vs Waittime each round', 'Waiting time in Second(s)', 'Total Turnaround Time for each run(in Milliseconds)')
        self.generate_permutations(r_d, w_d, d_d, 2, tot_dict, 'Turnaround Time Vs Message Loss each round', 'Message Loss in Fraction', 'Total Turnaround Time for each run(in Milliseconds)')
        self.generate_permutations(d_d, r_d, w_d, 3, tot_dict, 'Turnaround Time Vs Waittime each round', 'Delay in Second(s)', 'Total Turnaround Time for each run(in Milliseconds)')
        plt.show()

    def runner(self, r, d, w):
        timer_avg = 0
        time_algo = [None, None, None, None]
        time_algo2 = [None, None, None, None]
        t = time.clock()
        for i in range(self.n):
            acceptors = da.new(Acceptor_orig, num=self.a)
            proposers = da.new(Proposer_orig, num=self.pal)
            learners = da.new(Learner_orig, num=self.l)
            for p in acceptors:
                da.setup(p, (learners, self.id, r))
            for p in proposers:
                da.setup(p, (acceptors, r, d, w, self.id))
            for p in learners:
                da.setup(p, (acceptors, self.id))
            da.start(((acceptors | proposers) | learners))
            for p in learners:
                p.join()
            da.send(('done',), to=(acceptors | proposers))
            self.safety_check(i, ' <original> ')
            timer_avg += self.time_sum
            self.time_sum = 0
        time_algo2[0] = ((time.clock() - t) / self.n)
        time_algo[0] = (timer_avg / self.n)
        t = time.clock()
        for i in range(self.n):
            acceptors = da.new(Acceptor_to, num=self.a)
            proposers = da.new(Proposer_to, num=self.pal)
            learners = da.new(Learner_to, num=self.l)
            for p in acceptors:
                da.setup(p, (learners, self.id, r))
            for p in proposers:
                da.setup(p, (acceptors, r, d, w, self.tp, self.id))
            for p in learners:
                da.setup(p, (acceptors, self.tl, self.id))
            da.start(((acceptors | proposers) | learners))
            for p in learners:
                p.join()
            da.send(('done',), to=(acceptors | proposers))
            self.safety_check(i, ' <timeout> ')
            timer_avg += self.time_sum
            self.time_sum = 0
        time_algo2[1] = ((time.clock() - t) / self.n)
        time_algo[1] = (timer_avg / self.n)
        t = time.clock()
        for i in range(self.n):
            acceptors = da.new(Acceptor_pe, num=self.a)
            proposers = da.new(Proposer_pe, num=self.pal)
            learners = da.new(Learner_pe, num=self.l)
            for p in acceptors:
                da.setup(p, (learners, self.id, r))
            for p in proposers:
                da.setup(p, (acceptors, r, d, w, self.id))
            for p in learners:
                da.setup(p, (acceptors, self.id))
            da.start(((acceptors | proposers) | learners))
            for p in learners:
                p.join()
            da.send(('done',), to=(acceptors | proposers))
            self.safety_check(i, '<preemption>')
            timer_avg += self.time_sum
            self.time_sum = 0
        time_algo2[2] = ((time.clock() - t) / self.n)
        time_algo[2] = (timer_avg / self.n)
        t = time.clock()
        for i in range(self.n):
            acceptors = da.new(Acceptor_peto, num=self.a)
            proposers = da.new(Proposer_peto, num=self.pal)
            learners = da.new(Learner_peto, num=self.l)
            for p in acceptors:
                da.setup(p, (learners, self.id, r))
            for p in proposers:
                da.setup(p, (acceptors, r, d, w, self.tp, self.id))
            for p in learners:
                da.setup(p, (acceptors, self.tl, self.id))
            da.start(((acceptors | proposers) | learners))
            for p in learners:
                p.join()
            da.send(('done',), to=(acceptors | proposers))
            self.safety_check(i, '<preemption-timeout>')
            timer_avg += self.time_sum
            self.time_sum = 0
        time_algo2[3] = ((time.clock() - t) / self.n)
        time_algo[3] = (timer_avg / (self.n * ((self.a + self.pal) + self.l)))
        return (time_algo, time_algo2)

    def _driverclass_handler_16(self, s):
        for el in s:
            self.proposed_values_set.add(el)
        self.proposer_count += 1
    _driverclass_handler_16._labels = None
    _driverclass_handler_16._notlabels = None

    def _driverclass_handler_17(self, val):
        self.learners_values.add(val)
        self.learners_count += 1
    _driverclass_handler_17._labels = None
    _driverclass_handler_17._notlabels = None

    def _driverclass_handler_18(self, val):
        self.accepted_values.add(val)
    _driverclass_handler_18._labels = None
    _driverclass_handler_18._notlabels = None

    def _driverclass_handler_19(self, x):
        self.time_sum += x
    _driverclass_handler_19._labels = None
    _driverclass_handler_19._notlabels = None

def main():
    p = (int(sys.argv[1]) if (len(sys.argv) > 1) else 10)
    a = (int(sys.argv[2]) if (len(sys.argv) > 2) else 1)
    l = (int(sys.argv[3]) if (len(sys.argv) > 3) else 1)
    n = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
    r = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0.2)
    d = (int(sys.argv[6]) if (len(sys.argv) > 6) else 1)
    w = (int(sys.argv[7]) if (len(sys.argv) > 7) else 1)
    tp = (int(sys.argv[8]) if (len(sys.argv) > 8) else 2)
    tl = (int(sys.argv[9]) if (len(sys.argv) > 9) else 50)
    ml = (int(sys.argv[10]) if (len(sys.argv) > 10) else 3)
    de = (int(sys.argv[11]) if (len(sys.argv) > 11) else 3)
    wa = (int(sys.argv[12]) if (len(sys.argv) > 12) else 3)
    driver = da.new(driverclass, num=1)
    da.setup(driver, (p, a, l, n, r, d, w, tp, tl, ml, de, wa))
    da.start(driver)
